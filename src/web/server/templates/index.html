{% extends "layout.html" %}

{% block title %}MiniGrid Game{% endblock %}

{% block content %}
<div class="bg-white shadow rounded-lg p-6">
    <h2 class="text-2xl font-bold mb-4">MiniGrid Custom Maze</h2>
    {% if error %}
        <div class="text-red-500 mb-4">{{ error }}</div>
    {% endif %}
    <div class="game-container">
        <div class="flex flex-col items-center">
            <div class="mb-4">
                <label class="inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="viewToggle" class="sr-only peer">
                    <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    <span class="ml-3 text-sm font-medium text-gray-900">Agent View</span>
                </label>
            </div>
            <canvas id="gameCanvas" 
                    width="{{ render_width if render_width else 400 }}" 
                    height="{{ render_height if render_height else 400 }}" 
                    class="border border-gray-300">
            </canvas>
            <div class="flex justify-center space-x-4 mt-4">
                <button data-action="0" class="action-btn px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">↺ (A)</button>
                <button data-action="2" class="action-btn px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">↑ (W)</button>
                <button data-action="1" class="action-btn px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">↻ (D)</button>
            </div>
        </div>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let lastActionTime = 0;
const DEBOUNCE_TIME = 100; // ms

function displayGame(gameData) {
    if (!gameData) return;
    
    try {
        const width = gameData[0].length;
        const height = gameData.length;
        
        // Update canvas size to match the container size
        const container = canvas.parentElement;
        const containerSize = Math.min(container.clientWidth, 400);
        canvas.width = containerSize;
        canvas.height = containerSize;
        
        // Clear the entire canvas
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Create the image data
        const buffer = new Uint8ClampedArray(width * height * 4);
        const data = new ImageData(buffer, width, height);
        
        let i = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const pixel = gameData[y][x];
                buffer[i] = pixel[0];     // R
                buffer[i + 1] = pixel[1]; // G
                buffer[i + 2] = pixel[2]; // B
                buffer[i + 3] = 255;      // A
                i += 4;
            }
        }
        
        // Create a temporary canvas to hold the image data
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(data, 0, 0);
        
        // Calculate scaling and position to center the image
        const scale = Math.min(canvas.width / width, canvas.height / height);
        const scaledWidth = width * scale;
        const scaledHeight = height * scale;
        const x = (canvas.width - scaledWidth) / 2;
        const y = (canvas.height - scaledHeight) / 2;
        
        // Draw the scaled image centered on the main canvas
        ctx.imageSmoothingEnabled = false; // Keep pixel art sharp
        ctx.drawImage(tempCanvas, x, y, scaledWidth, scaledHeight);
        
    } catch (error) {
        console.error('Error displaying game:', error);
    }
}

async function performAction(action) {
    const now = Date.now();
    if (now - lastActionTime < DEBOUNCE_TIME) return;
    lastActionTime = now;

    try {
        const response = await fetch('/action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: action })
        });
        
        if (response.ok) {
            const gameData = await response.json();
            displayGame(gameData);
        }
    } catch (error) {
        console.error('Error:', error);
    }
}

// Add keyboard controls
document.addEventListener('keydown', (e) => {
    switch(e.key.toLowerCase()) {
        case 'a': performAction(0); break;
        case 'w': performAction(2); break;
        case 'd': performAction(1); break;
    }
});

// Add click listeners to all buttons
document.querySelectorAll('.action-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        performAction(parseInt(btn.dataset.action));
    });
});

// Add view toggle handler
document.getElementById('viewToggle').addEventListener('change', async (e) => {
    try {
        const response = await fetch('/toggle_view', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ agent_view: e.target.checked })
        });
        
        if (response.ok) {
            const gameData = await response.json();
            displayGame(gameData);
        }
    } catch (error) {
        console.error('Error:', error);
    }
});

{% if game_render %}
displayGame({{ game_render | tojson }});
{% endif %}
</script>
{% endblock %}
